# 关于InnoDB的Compression

> [MySQL文档: https://dev.mysql.com/doc/refman/5.7/en/innodb-compression.html](https://dev.mysql.com/doc/refman/5.7/en/innodb-compression.html)

>[InnoDB Transparent Page Compression](http://mysqlserverteam.com/innodb-transparent-page-compression/)

> [how innodb lost its advantage](https://dom.as/2015/04/09/how-innodb-lost-its-advantage/)

>[InnoDB Transparent PageIO Compression](http://mysqlserverteam.com/innodb-transparent-pageio-compression/)

>[MySQL · 社区动态 · InnoDB Page Compression](http://mysql.taobao.org/monthly/2015/08/01/)


压缩从5.1版本就被加入了MySQL，5.7版本中，又加入了Transparent Page 
Compression这个新特性。

### Transparent Page Compression

#### 源码阅读：

`extra/lz4`这个文件夹包含了lz4的库函数，而对于InnoDB的透明页压缩的压缩和解压操作，貌似只用到了LZ4_compress_limitedOutput、LZ4_decompress_safe、LZ4_decompress_fast这三个函数。

在`storage/innobase/os/os0file.cc`中:
* 压缩操作：
```cpp
/** Compress a data page
#param[in]	block_size	File system block size
@param[in]	src		Source contents to compress
@param[in]	src_len		Length in bytes of the source
@param[out]	dst		Compressed page contents
@param[out]	dst_len		Length in bytes of dst contents
@return buffer data, dst_len will have the length of the data */
static
byte*
os_file_compress_page(
	Compression	compression,
	ulint		block_size,
	byte*		src,
	ulint		src_len,
	byte*		dst,
	ulint*		dst_len)
{
        //.......
	switch (compression.m_type) {
	case Compression::NONE:
		ut_error;

	case Compression::ZLIB: {
                //.................
		break;
	}

	case Compression::LZ4:
		len = LZ4_compress_limitedOutput(
			reinterpret_cast<char*>(src) + FIL_PAGE_DATA,
			reinterpret_cast<char*>(dst) + FIL_PAGE_DATA,
			static_cast<int>(content_len),
			static_cast<int>(out_len));
		ut_a(len <= src_len - FIL_PAGE_DATA);
		if (len == 0  || len >= out_len) {
			*dst_len = src_len;
			return(src);
		}
		break;
	default:
		*dst_len = src_len;
		return(src);
	}
	//..........
	return(dst);
}
```

* 解压缩操作
```cpp
/** Decompress the page data contents. Page type must be FIL_PAGE_COMPRESSED, if
not then the source contents are left unchanged and DB_SUCCESS is returned.
@param[in]	dblwr_recover	true of double write recovery in progress
@param[in,out]	src		Data read from disk, decompressed data will be
				copied to this page
@param[in,out]	dst		Scratch area to use for decompression
@param[in]	dst_len		Size of the scratch area in bytes
@return DB_SUCCESS or error code */
dberr_t
Compression::deserialize(
	bool		dblwr_recover,
	byte*		src,
	byte*		dst,
	ulint		dst_len)
{
        //....... 
	switch(compression.m_type) {
	case Compression::ZLIB: {
		//..........
		break;
	}
	case Compression::LZ4:
		if (dblwr_recover) {
			ret = LZ4_decompress_safe(
				reinterpret_cast<char*>(ptr),
				reinterpret_cast<char*>(dst),
				header.m_compressed_size,
				header.m_original_size);
		} else {
			/* This can potentially read beyond the input
			buffer if the data is malformed. According to
			the LZ4 documentation it is a little faster
			than the above function. When recovering from
			the double write buffer we can afford to us the
			slower function above. */
			ret = LZ4_decompress_fast(
				reinterpret_cast<char*>(ptr),
				reinterpret_cast<char*>(dst),
				header.m_original_size);
		}
		if (ret < 0) {
			if (block != NULL) {
				os_free_block(block);
			}
			return(DB_IO_DECOMPRESS_FAIL);
		}
		break;
	default:
                //..........
		return(DB_UNSUPPORTED);
	}
	//............
	return(DB_SUCCESS);
}
```



