# 关于InnoDB的Compression

> [MySQL文档: https://dev.mysql.com/doc/refman/5.7/en/innodb-compression.html](https://dev.mysql.com/doc/refman/5.7/en/innodb-compression.html)

>[InnoDB Transparent Page Compression](http://mysqlserverteam.com/innodb-transparent-page-compression/)

> [how innodb lost its advantage](https://dom.as/2015/04/09/how-innodb-lost-its-advantage/)

>[InnoDB Transparent PageIO Compression](http://mysqlserverteam.com/innodb-transparent-pageio-compression/)

>[MySQL · 社区动态 · InnoDB Page Compression](http://mysql.taobao.org/monthly/2015/08/01/)


压缩从5.1版本就被加入了MySQL，5.7版本中，又加入了Transparent Page 
Compression这个新特性。

### Transparent Page Compression

#### 源码阅读：

`extra/lz4`这个文件夹包含了lz4的库函数，而对于InnoDB的透明页压缩的压缩和解压操作，貌似只用到了LZ4_compress_limitedOutput、LZ4_decompress_safe、LZ4_decompress_fast这三个函数。

在`storage/innobase/os/os0file.cc`中，压缩操作：
```cpp
/** Compress a data page
#param[in]	block_size	File system block size
@param[in]	src		Source contents to compress
@param[in]	src_len		Length in bytes of the source
@param[out]	dst		Compressed page contents
@param[out]	dst_len		Length in bytes of dst contents
@return buffer data, dst_len will have the length of the data */
static
byte*
os_file_compress_page(
	Compression	compression,
	ulint		block_size,
	byte*		src,
	ulint		src_len,
	byte*		dst,
	ulint*		dst_len)
{
	ulint		len = 0;
	ulint		compression_level = page_zip_level;
	ulint		page_type = mach_read_from_2(src + FIL_PAGE_TYPE);

	/* The page size must be a multiple of the OS punch hole size. */
	ut_ad(!(src_len % block_size));

	/* Shouldn't compress an already compressed page. */
	ut_ad(page_type != FIL_PAGE_COMPRESSED);

	/* The page must be at least twice as large as the file system
	block size if we are to save any space. Ignore R-Tree pages for now,
	they repurpose the same 8 bytes in the page header. No point in
	compressing if the file system block size >= our page size. */
	//...

	/* Leave the header alone when compressing. */
        //.......

	/* Must compress to <= N-1 FS blocks. */
	ulint		out_len = src_len - (FIL_PAGE_DATA + block_size);

	/* This is the original data page size - the page header. */
	//.......
	/* Only compress the data + trailer, leave the header alone */

	switch (compression.m_type) {
	case Compression::NONE:
		ut_error;

	case Compression::ZLIB: {
                //.................
		break;
	}

	case Compression::LZ4:

		len = LZ4_compress_limitedOutput(
			reinterpret_cast<char*>(src) + FIL_PAGE_DATA,
			reinterpret_cast<char*>(dst) + FIL_PAGE_DATA,
			static_cast<int>(content_len),
			static_cast<int>(out_len));

		ut_a(len <= src_len - FIL_PAGE_DATA);

		if (len == 0  || len >= out_len) {

			*dst_len = src_len;

			return(src);
		}

		break;

	default:
		*dst_len = src_len;
		return(src);
	}

	//..........

	return(dst);
}
```
